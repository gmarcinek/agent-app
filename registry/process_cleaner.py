"""
Process Cleaner - Dedykowany modu≈Ç do zamykania i czyszczenia proces√≥w
"""
import subprocess
import threading
import time
from typing import Dict, List, Optional, NamedTuple


class CleanupReport(NamedTuple):
    """Raport z procesu czyszczenia"""
    total_processes: int
    active_before: int
    zombie_before: int
    remaining_alive: int
    zombie_after: int
    zombie_pids: List[int]
    cleanup_time: float
    threads_cleaned: int
    errors: List[str]


class ProcessCleaner:
    """Dedykowany cleaner do zamykania proces√≥w i thread√≥w"""
    
    def __init__(self, log_hub=None):
        self.log_hub = log_hub
    
    def cleanup_all(self, 
                   processes: Dict[str, subprocess.Popen], 
                   process_threads: Dict[str, threading.Thread],
                   timeout: int = 2,  # Skr√≥cone z 5s na 2s
                   thread_timeout: int = 1) -> CleanupReport:  # Skr√≥cone z 3s na 1s
        """
        Kompletne czyszczenie wszystkich proces√≥w i thread√≥w
        
        Args:
            processes: Dict proces√≥w do zamkniƒôcia
            process_threads: Dict thread√≥w do zamkniƒôcia
            timeout: Timeout dla graceful shutdown proces√≥w
            thread_timeout: Timeout dla join thread√≥w
            
        Returns:
            CleanupReport z detalami procesu czyszczenia
        """
        print("üîÑ Starting complete cleanup sequence...")
        start_time = time.time()
        errors = []
        
        if self.log_hub:
            self.log_hub.group_start("CLEANER", "Complete system cleanup")
        
        # Analiza stanu przed cleanup
        pre_cleanup = self._analyze_processes(processes)
        self._print_pre_cleanup_status(processes)
        
        try:
            # 1. Zamknij wszystkie procesy
            print("üßπ Phase 1: Shutting down processes...")
            self._shutdown_all_processes(processes, timeout, errors)
            
            # 2. Cleanup thread√≥w
            print("üßµ Phase 2: Cleaning up threads...")
            threads_cleaned = self._cleanup_all_threads(process_threads, thread_timeout, errors)
            
            # 3. Final analysis
            post_cleanup = self._analyze_processes(processes)
            cleanup_time = time.time() - start_time
            
            # Stw√≥rz raport
            report = CleanupReport(
                total_processes=pre_cleanup['total'],
                active_before=pre_cleanup['active'],
                zombie_before=pre_cleanup['zombie'],
                remaining_alive=post_cleanup['active'],
                zombie_after=post_cleanup['zombie'],
                zombie_pids=post_cleanup['zombie_pids'],
                cleanup_time=cleanup_time,
                threads_cleaned=threads_cleaned,
                errors=errors
            )
            
            self._print_cleanup_summary(report)
            
            if self.log_hub:
                status = "with errors" if errors else "successfully"
                self.log_hub.group_end("CLEANER", f"Cleanup completed {status} in {cleanup_time:.2f}s")
            
            return report
            
        except Exception as e:
            error_msg = f"Critical cleanup error: {e}"
            print(f"‚ùå {error_msg}")
            errors.append(error_msg)
            
            # Return partial report
            return CleanupReport(
                total_processes=pre_cleanup['total'],
                active_before=pre_cleanup['active'],
                zombie_before=pre_cleanup['zombie'],
                remaining_alive=len([p for p in processes.values() if p.poll() is None]),
                zombie_after=len([p for p in processes.values() if p.poll() is not None]),
                zombie_pids=[p.pid for p in processes.values() if p.poll() is not None],
                cleanup_time=time.time() - start_time,
                threads_cleaned=0,
                errors=errors
            )
    
    def cleanup_single_process(self, name: str, process: subprocess.Popen, timeout: int = 2) -> bool:  # Skr√≥cone z 5s na 2s
        """
        Zamyka pojedynczy proces gracefully
        
        Returns:
            True je≈õli proces zosta≈Ç zamkniƒôty, False w przypadku b≈Çƒôdu
        """
        if process.poll() is not None:
            print(f"üíÄ Process {name} already dead (exit code: {process.poll()})")
            return True
        
        try:
            print(f"ü§ù Graceful shutdown: {name} (PID {process.pid})")
            
            # Zamknij stdin przed terminacjƒÖ
            if process.stdin and not process.stdin.closed:
                try:
                    process.stdin.close()
                except:
                    pass  # Ignore stdin close errors
            
            # Wy≈õlij SIGTERM
            process.terminate()
            
            # Czekaj na graceful shutdown
            try:
                process.wait(timeout=timeout)
                print(f"‚úÖ {name} terminated gracefully")
                return True
            except subprocess.TimeoutExpired:
                print(f"‚ö° Timeout! Force killing {name} (PID {process.pid})")
                process.kill()
                process.wait()  # Clean up zombie
                print(f"üí• {name} force killed")
                return True
                
        except ProcessLookupError:
            print(f"üëª Process {name} disappeared during shutdown")
            return True  # Consider this success
        except Exception as e:
            print(f"‚ùå Error stopping {name}: {e}")
            try:
                process.kill()  # Last resort
                process.wait()
                return True
            except:
                return False
    
    def _analyze_processes(self, processes: Dict[str, subprocess.Popen]) -> Dict:
        """Analizuje stan proces√≥w"""
        active = [p for p in processes.values() if p.poll() is None]
        zombie = [p for p in processes.values() if p.poll() is not None]
        
        return {
            'total': len(processes),
            'active': len(active),
            'zombie': len(zombie),
            'zombie_pids': [p.pid for p in zombie]
        }
    
    def _print_pre_cleanup_status(self, processes: Dict[str, subprocess.Popen]) -> None:
        """Wy≈õwietla status przed cleanup"""
        analysis = self._analyze_processes(processes)
        
        print(f"üìä Pre-cleanup status:")
        print(f"   üü¢ Active processes: {analysis['active']}")
        print(f"   üßü Zombie processes: {analysis['zombie']}")
        print(f"   üìà Total processes: {analysis['total']}")
        
        for name, process in processes.items():
            status = "ALIVE" if process.poll() is None else f"DEAD ({process.poll()})"
            print(f"   üìä {name}: PID {process.pid} - {status}")
    
    def _shutdown_all_processes(self, processes: Dict[str, subprocess.Popen], 
                              timeout: int, errors: List[str]) -> None:
        """Zamyka wszystkie procesy r√≥wnocze≈õnie (parallel approach)"""
        if not processes:
            print("üíÄ No processes to shutdown")
            return
        
        process_list = list(processes.items())
        print(f"üíÄ Starting parallel shutdown of {len(process_list)} processes...")
        
        # FAZA 1: Wy≈õlij SIGTERM do wszystkich r√≥wnocze≈õnie
        print("ü§ù Phase 1: Sending SIGTERM to all processes...")
        alive_processes = []
        
        for name, process in process_list:
            if process.poll() is not None:
                print(f"üíÄ {name} already dead (exit code: {process.poll()})")
                continue
                
            try:
                print(f"ü§ù Sending SIGTERM to {name} (PID {process.pid})")
                
                # Zamknij stdin przed terminacjƒÖ
                if process.stdin and not process.stdin.closed:
                    try:
                        process.stdin.close()
                    except:
                        pass
                
                process.terminate()
                alive_processes.append((name, process))
                
            except ProcessLookupError:
                print(f"üëª Process {name} disappeared before terminate")
            except Exception as e:
                error_msg = f"Error terminating {name}: {e}"
                print(f"‚ùå {error_msg}")
                errors.append(error_msg)
        
        if not alive_processes:
            print("‚úÖ All processes were already dead")
            return
        
        # FAZA 2: Czekaj na graceful shutdown wszystkich (parallel wait)
        print(f"‚è≥ Phase 2: Waiting up to {timeout}s for graceful shutdown...")
        start_time = time.time()
        check_interval = 0.1  # Sprawdzaj co 100ms
        
        while alive_processes and (time.time() - start_time) < timeout:
            # Sprawd≈∫ kt√≥re procesy siƒô zako≈Ñczy≈Çy
            still_alive = []
            for name, process in alive_processes:
                if process.poll() is None:
                    still_alive.append((name, process))
                else:
                    print(f"‚úÖ {name} terminated gracefully")
            
            alive_processes = still_alive
            
            if alive_processes:
                time.sleep(check_interval)
        
        # FAZA 3: Force kill survivors r√≥wnocze≈õnie
        if alive_processes:
            print(f"‚ö° Phase 3: Force killing {len(alive_processes)} survivors...")
            
            for name, process in alive_processes:
                try:
                    print(f"üí• Force killing {name} (PID {process.pid})")
                    process.kill()
                except ProcessLookupError:
                    print(f"üëª Process {name} disappeared before kill")
                except Exception as e:
                    error_msg = f"Error force killing {name}: {e}"
                    print(f"‚ùå {error_msg}")
                    errors.append(error_msg)
            
            # Czekaj na cleanup zombie processes
            print("üßü Cleaning up killed processes...")
            for name, process in alive_processes:
                try:
                    process.wait(timeout=1)  # Kr√≥tki timeout na cleanup
                    print(f"üí• {name} force killed successfully")
                except subprocess.TimeoutExpired:
                    error_msg = f"Process {name} didn't die after force kill"
                    print(f"‚ùå {error_msg}")
                    errors.append(error_msg)
                except Exception as e:
                    error_msg = f"Error waiting for {name} cleanup: {e}"
                    print(f"‚ùå {error_msg}")
                    errors.append(error_msg)
        else:
            print("üéâ All processes terminated gracefully - no force kill needed!")
        
        total_time = time.time() - start_time
        print(f"‚úÖ Parallel shutdown complete in {total_time:.2f}s")
    
    def _cleanup_all_threads(self, process_threads: Dict[str, threading.Thread], 
                           timeout: int, errors: List[str]) -> int:
        """Cleanup wszystkich thread√≥w"""
        if not process_threads:
            print("üßµ No threads to cleanup")
            return 0
        
        print(f"üßµ Cleaning up {len(process_threads)} threads...")
        
        alive_threads = [(name, thread) for name, thread in process_threads.items() 
                        if thread.is_alive()]
        
        if not alive_threads:
            print("üßµ All threads already dead")
            return len(process_threads)
        
        print(f"‚è≥ Waiting for {len(alive_threads)} threads to finish...")
        cleaned_count = 0
        
        for name, thread in alive_threads:
            print(f"   ‚è≥ Joining thread {name}...")
            thread.join(timeout=timeout)
            
            if thread.is_alive():
                # Daemon threads mogƒÖ siƒô nie zako≈Ñczyƒá - to OK
                if thread.daemon:
                    print(f"   üîÑ Thread {name} is daemon - will exit with main process")
                    cleaned_count += 1  # Count as cleaned since it's daemon
                else:
                    error_msg = f"Thread {name} didn't stop cleanly (still alive)"
                    print(f"   ‚ö†Ô∏è  {error_msg}")
                    errors.append(error_msg)
            else:
                print(f"   ‚úÖ Thread {name} joined successfully")
                cleaned_count += 1
        
        # Check for non-daemon zombie threads
        still_alive = [name for name, thread in process_threads.items() 
                      if thread.is_alive() and not thread.daemon]
        
        if still_alive:
            print(f"‚ö†Ô∏è  Non-daemon zombie threads: {still_alive}")
            print("   üí° These threads may need manual intervention")
        else:
            print("üßµ All critical threads cleaned up!")
        
        return cleaned_count
        
    def _print_cleanup_summary(self, report: CleanupReport) -> None:
        """Wy≈õwietla podsumowanie cleanup z auto-killing zombie PIDs"""
        print("\n" + "="*50)
        print("‚ú® CLEANUP SUMMARY üéâ")
        print("="*50)
        
        print(f"‚è±Ô∏è  Total cleanup time: {report.cleanup_time:.2f}s")
        print(f"üìä Processes handled: {report.total_processes}")
        print(f"üßµ Threads cleaned: {report.threads_cleaned}")
        print(f"üìà Active threads remaining: {threading.active_count()}")
        
        if report.remaining_alive > 0:
            print(f"‚ö†Ô∏è  Processes still alive: {report.remaining_alive}")
        
        if report.zombie_pids:
            print(f"üßü Found {len(report.zombie_pids)} zombie PIDs")
            for pid in report.zombie_pids:
                print(f"   üíÄ PID {pid}")
            
            # Auto-kill zombies
            self._auto_kill_zombies(report.zombie_pids)
        else:
            print("üßü No zombie processes - squeaky clean!")
        
        if report.errors:
            print(f"‚ùå Errors encountered: {len(report.errors)}")
            for error in report.errors:
                print(f"   ‚ö†Ô∏è  {error}")
        else:
            print("‚úÖ No errors - perfect cleanup!")
        
        print("="*50)
        print("üéØ All systems shutdown complete! Papa would be proud! üéâ")
        print("="*50)

    def _auto_kill_zombies(self, zombie_pids: List[int]) -> None:
        """Auto-kill zombie PIDs - Windows compatible"""
        import os
        import signal
        import sys
        
        print(f"üî™ Auto-killing {len(zombie_pids)} zombies...")
        
        for pid in zombie_pids:
            try:
                # Cross-platform process killing
                if sys.platform == "win32":
                    # Windows: u≈ºyj os.kill z SIGTERM lub subprocess
                    import subprocess
                    subprocess.run(["taskkill", "/F", "/PID", str(pid)], 
                                capture_output=True, check=False)
                    print(f"   ‚úÖ Killed PID {pid} (Windows)")
                else:
                    # Unix: u≈ºyj SIGKILL
                    os.kill(pid, 0)  # Check existence
                    os.kill(pid, signal.SIGKILL)  # Kill
                    print(f"   ‚úÖ Killed PID {pid} (Unix)")
                    
            except ProcessLookupError:
                print(f"   üëª PID {pid} already gone")
            except Exception as e:
                print(f"   ‚ùå Failed PID {pid}: {e}")
        
        print("üßΩ Auto-cleanup complete!")


# Utility functions dla prostszego u≈ºycia
def quick_cleanup(processes: Dict[str, subprocess.Popen], 
                 process_threads: Dict[str, threading.Thread] = None,
                 log_hub=None) -> CleanupReport:
    """Quick cleanup function dla prostego u≈ºycia"""
    cleaner = ProcessCleaner(log_hub)
    return cleaner.cleanup_all(processes, process_threads or {})


def emergency_kill_all(processes: Dict[str, subprocess.Popen]) -> List[int]:
    """Emergency kill wszystkich proces√≥w - bez graceful shutdown"""
    print("üö® EMERGENCY KILL MODE - NO MERCY! üíÄ")
    killed_pids = []
    
    for name, process in processes.items():
        if process.poll() is None:  # Still alive
            try:
                print(f"üíÄ Emergency killing {name} (PID {process.pid})")
                process.kill()
                process.wait()
                killed_pids.append(process.pid)
                print(f"üí• {name} emergency killed")
            except Exception as e:
                print(f"‚ùå Failed to emergency kill {name}: {e}")
    
    print(f"üö® Emergency kill complete - killed {len(killed_pids)} processes")
    return killed_pids
